If you want to create your own title bar in Kivy with minimize, maximize, close, and window buttons, you have to perform the below steps. Please note that these code changes will ONLY work on Windows OS. 

The first set of steps below involve updating the Window Kivy Source code located here: Python37-32\Lib\site-packages\kivy\core\window\__init__.py. You can open the Window Kivy source code file using an IDE to modify the code.

1) Within the Window Kivy Source code file, there are import statements at the top. Insert these new import statements (see where it says NEW CODE HERE):

Here is what it should look like:

from os.path import join, exists
from os import getcwd

from kivy.core import core_select_lib
from kivy.clock import Clock
from kivy.config import Config
from kivy.logger import Logger
from kivy.base import EventLoop, stopTouchApp
from kivy.modules import Modules
from kivy.event import EventDispatcher
from kivy.properties import ListProperty, ObjectProperty, AliasProperty, \
    NumericProperty, OptionProperty, StringProperty, BooleanProperty
from kivy.utils import platform, reify, deprecated
from kivy.context import get_current_context
from kivy.uix.behaviors import FocusBehavior
from kivy.setupconfig import USE_SDL2
from kivy.graphics.transformation import Matrix
from kivy.graphics.cgl import cgl_get_backend_name
from win32api import GetMonitorInfo #NEW CODE HERE - NOTE: THIS CODE WILL ONLY WORK IN WINDOWS SINCE IT USES WINDOWS API FUNCTIONS
import win32api #NEW CODE HERE
 
2) Within the WindowBase class, we need to create and populate some new variables. Please see below.

class WindowBase(EventDispatcher):

    #NEW CODE HERE - NOTE: THIS CODE WILL ONLY WORK IN WINDOWS SINCE IT USES WINDOWS API FUNCTIONS
    monitors = win32api.EnumDisplayMonitors() #fetch all of the monitor handles..
    monitor_data_excl_taskbar = []
    monitor_data_incl_taskbar = []
    for x in range(0, len(monitors)): #loop through the monitors and store data about them..
        #store all monitor data EXCLUDING the taskbars..
        monitor_info = GetMonitorInfo(monitors[x][0]).get("Work") 
        x1_pos = monitor_info[0]
        x2_pos = monitor_info[2]
        y1_pos = monitor_info[1]
        y2_pos = monitor_info[3]
        screen_width = x2_pos - x1_pos
        screen_height = y2_pos - y1_pos
        monitor_data_excl_taskbar.append([x1_pos, x2_pos, y1_pos, y2_pos, screen_width, screen_height])
        #store all monitor data INCLUDING the taskbars..
        monitor_info = GetMonitorInfo(monitors[x][0]).get("Monitor")
        x1_pos = monitor_info[0]
        x2_pos = monitor_info[2]
        y1_pos = monitor_info[1]
        y2_pos = monitor_info[3]
        screen_width = x2_pos - x1_pos
        screen_height = y2_pos - y1_pos
        monitor_data_incl_taskbar.append([x1_pos, x2_pos, y1_pos, y2_pos, screen_width, screen_height])
    disable_on_restore = 'N'
    maximize_trigger = 'N'
    original_screen_pos_left = monitor_data_excl_taskbar[0][0] #get the x position of the primary screen's resolution excluding taskbars
    original_screen_pos_top = monitor_data_excl_taskbar[0][2] #get the y position of the primary screen's resolution excluding taskbars
    original_screen_width = monitor_data_excl_taskbar[0][4] #get the width of the primary screen's resolution excluding taskbars
    original_screen_height = monitor_data_excl_taskbar[0][5] #get the height of the primary screen's resolution excluding taskbars
    last_screen_pos_left = original_screen_pos_left
    last_screen_pos_top = original_screen_pos_top
    last_screen_width = original_screen_width 
    last_screen_height = original_screen_height

    '''WindowBase is an abstract window widget for any window implementation.

We put these 10 new variables into the WindowBase class, right at the top. 

3) Locate the 'def on_minimize' method and modify it to the following:

    def on_minimize(self, *largs):
        '''Event called when the window is minimized.

        .. versionadded:: 1.10.0

        .. note::
            This feature requires the SDL2 window provider.
        '''
        #NEW CODE HERE
        Window.maximize_trigger = 'N'
        pass

4) Locate the 'def on_maximize' method and modify it to the following:

    def on_maximize(self, *largs):
        '''Event called when the window is maximized.

        .. versionadded:: 1.10.0

        .. note::
            This feature requires the SDL2 window provider.
        '''
        #NEW CODE HERE
        Window.maximize_trigger = 'Y'
        pass

5) Locate the 'def on_restore' method and modify it to the following:

    def on_restore(self, *largs):
        '''Event called when the window is restored.

        .. versionadded:: 1.10.0

        .. note::
            This feature requires the SDL2 window provider.
       
        '''
        #NEW CODE HERE
        if Window.disable_on_restore == 'N': #we have to disable this on_restore event from running when the app size is reduced using windowed button
            Window.left = Window.last_screen_pos_left
	    Window.top = Window.last_screen_pos_top
            Window.size = [Window.last_screen_width, Window.last_screen_height]
        pass


6) Create 2 new methods called 'enable_borderless' and 'disable_borderless' and place them under the existing 'on_minimize' method (see below):

    #NEW CODE
    def enable_borderless(self, *largs):
        Window.borderless = 0

    #NEW CODE
    def disable_borderless(self, *largs):
        Window.disable_on_restore = 'N' 
        Window.borderless = 1

The next set of steps below involve updating the Window SDL2 Kivy Source code located here: Python37-32\Lib\site-packages\kivy\core\window\window_sdl2.py. You can open the Window SDL2 Kivy source code file using an IDE to modify the code.

7) Add imports for time and threading at the top of the script (see below NEW CODE HERE):

# found a way to include it more easily.
'''
SDL2 Window
===========

Windowing provider directly based on our own wrapped version of SDL.

TODO:
    - fix keys
    - support scrolling
    - clean code
    - manage correctly all sdl events

'''

__all__ = ('WindowSDL2', )

from os.path import join
import sys
import time #NEW CODE HERE
import threading #NEW CODE HERE
from kivy import kivy_data_dir
from kivy.logger import Logger
from kivy.base import EventLoop, ExceptionManager, stopTouchApp

8) Locate the action code for 'windowfocusgained' and insert this new code:

     elif action == 'windowfocusgained':
          #NEW CODE HERE
          self.disable_borderless()
          self._focus = True

9) Locate the action code for 'windowfocuslost' and insert this new code:

     elif action == 'windowfocuslost':
         #NEW CODE HERE
         self.enable_borderless()
         threading.Thread(target=self.check_for_minimize).start()
         self._focus = False

10) Create a new method called 'check_for_minimize' and place it above the existing '_do_resize' method:

    #NEW CODE HERE
    def check_for_minimize(self):
        time.sleep(.5)
        Clock.schedule_once(self.disable_borderless)


The last set of steps involve the test.py file. This is a reference file for the code you will need to utilize in your App.

11) Locate the example test.py file and implement the code into your App. Within this test app, there are specific methods that are called to account for the user minimizing, maximizing, windowing, and closing the window using the 
buttons at the top. Since the native Windows title bar is gone, you must account for all aspects of the user manipulating the window using python: minimize, maximize, window, close, and window resizing.

12) Within your App's code, use the config object to force the window to NOT be resizable when the App launches by using these lines at the top of the import statements section:

from kivy.config import Config
Config.set('graphics','resizable', 0) 

NOTE: Put this at the very start of the import statements code!!! It must go before all other imports or it won't work properly.

